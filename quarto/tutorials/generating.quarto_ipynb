{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "editor:\n",
        "    render-on-save: true\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "# Generating analyses\n"
      ],
      "id": "c8186f79"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "#repo  = pwd()\n",
        "repo = pwd() |> dirname |> dirname"
      ],
      "id": "41bc0d94",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In Tabulae's model, a parser is just a collection of pre-computed analyses.\n",
        "\n",
        "\n",
        "The only \"generating\" we need to do is precomputing `Analysis` objects.\n",
        "\n",
        "## rule + stem == Analysis\n",
        "\n",
        "\n",
        "Example:\n"
      ],
      "id": "318f9885"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using CitableBase, Tabulae\n",
        "vstem = fromcex(\"latcommon.verbn12387|ls.n12387|deb|conj2\", TabulaeVerbStem)\n",
        "vrule = fromcex(\"latcommon.ere_conj2fut3|conj2|ebit|third|singular|future|indicative|active\", TabulaeFiniteVerbRule)\n",
        "verb = analysis(vstem, vrule)"
      ],
      "id": "02b64b49",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## analyses from a dataset\n",
        "\n",
        "A dataset gives you a whole collection of stems and rules to work with!\n"
      ],
      "id": "1dc355f5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "coresrcdir = joinpath(repo, \"datasets\", \"core-infl-shared\") \n",
        "tds = dataset([coresrcdir])"
      ],
      "id": "7966da17",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Lexeme + form\n",
        "\n",
        "Becuase stems are associated with a lexeme, you can generate analysis for a given form for a given lexem:\n"
      ],
      "id": "8e5e2b9a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using CitableParserBuilder\n",
        "lex = LexemeUrn(\"ls.n12387\")\n",
        "vform = formurn(vrule)\n",
        "analyses(lex, vform, tds)"
      ],
      "id": "74b71136",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# THIS IS ALL BROKEN\n"
      ],
      "id": "06d48fa8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| warning: false\n",
        "#| output: false\n",
        "using Tabulae, CitableParserBuilder\n",
        "\n",
        "shareddir = joinpath(repo, \"datasets\", \"core-infl-shared\") \n",
        "lat25dir = joinpath(repo, \"datasets\", \"core-infl-lat25\") \n",
        "ds = dataset([shareddir, lat25dir])\n",
        "parser =  tabulaeStringParser(ds)"
      ],
      "id": "99b432c1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generating forms using a parser\n",
        "\n",
        "To illustrate generating forms with a parser, we'll first analyze a token.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{juliabroken}\n",
        "parses = parsetoken(\"animo\", parser)\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "*animo* is morphologically ambiguous: it has two possible analyses.  We'll use the `latinForm` function to see the morphological form of the first analysis.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{juliabroken}\n",
        "form1 = latinForm(parses[1])\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "We'll now try to generate the same form using identifying URNs for the form and the lexeme.\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{juliabroken}\n",
        "lex = lexemeurn(parses[1])\n",
        "mform = formurn(parses[1])\n",
        "\n",
        "generated = generate(lex, mform, parser)\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "The result is a vector of `Analysis` objects -- the same structure that  `parsetoken` returns, but we only have one possible result for this specific form of this lexeme.  The `token` function extracts the string value of the token from an analysis\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{juliabroken}\n",
        "token(generated[1])\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Generating forms using a Tabulae dataset\n",
        "\n",
        "Using a dataset instead of a parser, we get the same results:\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{juliabroken}\n",
        "dsgenerated = generate(lex, mform, ds)\n",
        "dsgenerated .|> token\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "With a dataset, you also have the option of generating analyses from the combination of a lexeme identifier plus a full Latin morphological form, such as the noun form we saved from a previous analysis:\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "```{juliabroken}\n",
        "generate(lex, form1, ds)\n",
        "```"
      ],
      "id": "e42eaf61"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.10",
      "language": "julia",
      "display_name": "Julia 1.10.4",
      "path": "/Users/nsmith/Library/Jupyter/kernels/julia-1.10"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}