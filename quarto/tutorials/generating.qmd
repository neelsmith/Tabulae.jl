---
editor:
    render-on-save: true
---


# Generating analyses

```{julia}
#| echo: false
#| output: false
#repo  = pwd()
repo = pwd() |> dirname |> dirname
```



In Tabulae's model, a parser is just a collection of pre-computed analyses.


The only "generating" we need to do is precomputing `Analysis` objects.

## rule + stem == Analysis


Example:

```{julia}
using CitableBase, Tabulae
vstem = fromcex("latcommon.verbn12387|ls.n12387|deb|conj2", TabulaeVerbStem)
vrule = fromcex("latcommon.ere_conj2fut3|conj2|ebit|third|singular|future|indicative|active", TabulaeFiniteVerbRule)
verb = analysis(vstem, vrule)
```


## analyses from a dataset

A dataset gives you a whole collection of stems and rules to work with!

```{julia}
coresrcdir = joinpath(repo, "datasets", "core-infl-shared") 
tds = dataset([coresrcdir])
```


### Lexeme + form

Becuase stems are associated with a lexeme, you can generate analysis for a given form for a given lexem:

```{julia}
using CitableParserBuilder
lex = LexemeUrn("ls.n12387")
vform = formurn(vrule)
analyses(lex, vform, tds)
```





# THIS IS ALL BROKEN


```{julia}
#| warning: false
#| output: false
using Tabulae, CitableParserBuilder

shareddir = joinpath(repo, "datasets", "core-infl-shared") 
lat25dir = joinpath(repo, "datasets", "core-infl-lat25") 
ds = dataset([shareddir, lat25dir])
parser =  tabulaeStringParser(ds)
```


## Generating forms using a parser

To illustrate generating forms with a parser, we'll first analyze a token.



```{juliabroken}
parses = parsetoken("animo", parser)
```

*animo* is morphologically ambiguous: it has two possible analyses.  We'll use the `latinForm` function to see the morphological form of the first analysis.


```{juliabroken}
form1 = latinForm(parses[1])
```

We'll now try to generate the same form using identifying URNs for the form and the lexeme.

```{juliabroken}
lex = lexemeurn(parses[1])
mform = formurn(parses[1])

generated = generate(lex, mform, parser)
```

The result is a vector of `Analysis` objects -- the same structure that  `parsetoken` returns, but we only have one possible result for this specific form of this lexeme.  The `token` function extracts the string value of the token from an analysis

```{juliabroken}
token(generated[1])
```



## Generating forms using a Tabulae dataset

Using a dataset instead of a parser, we get the same results:

```{juliabroken}
dsgenerated = generate(lex, mform, ds)
dsgenerated .|> token
```

With a dataset, you also have the option of generating analyses from the combination of a lexeme identifier plus a full Latin morphological form, such as the noun form we saved from a previous analysis:

```{juliabroken}
generate(lex, form1, ds)
```