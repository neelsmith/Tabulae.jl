# Rule types

```{julia}
#| output: false
#| warning: false

repo = joinpath(pwd() |> dirname |> dirname)
```


We'll work with a dataset and a parser defined in this cell.

```{julia}
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: Define dataset and parser
shareddir = joinpath(repo, "datasets", "core-infl-shared") 
lat25dir = joinpath(repo, "datasets", "core-infl-lat25") 


using Tabulae
ds = dataset([shareddir, lat25dir])
p = tabulaeStringParser(ds)
```

::: {.callout-caution title="Contents TBA"}
TBA
:::

## Outline

- subtypes of TabulaeRule
- implement `readrulerow` and `writerulerow` using a subtype of `TabulaeIO`
- implement `latinform`, and all the (relevant) property functions
- implement `inflectiontype` and `ending`


## VerbRule

For finite forms

## InfinitiveRule


- use an `InfinitiveIO` object to read delimited text. The result is an `InfinitiveRule`.

```{julia}
infinitiveruletext = "latcommon.are_inf1|conj1|are|present|active"
using Tabulae
infinio = InfinitiveIO("infinitive io")
infinrule = Tabulae.readrulerow(infinio, infinitiveruletext)
```


## ParticipleRule

```{julia}
ptcplruletext = "latcommoninfl.are_conj1presapl2|conj1|antis|masculine|gen|singular|present|active"

ptpclio = ParticipleIO("participle io")
infinrule = Tabulae.readrulerow(ptpclio, ptcplruletext)
```


## NounRule


All inflectional types:

```{julia}
#| asis: true
using Markdown
stems = stemsarray(ds)
nounstems = filter(s -> s isa TabulaeNounStem, stems)
bullets = map(s -> "- " * inflectionType(s), nounstems) |> unique

join(bullets, "\n") |> Markdown.parse
```
